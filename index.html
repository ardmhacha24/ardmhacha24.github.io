<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prevent caching during development -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Grange Naomh Colmcille CLG - Fixtures & Results 2025</title>
    <meta name="theme-color" content="#006400">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="GNC CLG">
    <link rel="apple-touch-icon" href="/assets/IMG_9120-WHITE.png">
    <style>
        :root {
            --primary: #006400; /* Dark Green */
            --secondary: #ff8c00; /* Orange */
            --light-bg: #f5f5f5;
            --text: #333;
            --light-text: #666;
            --border: #ddd;
            --win: #d4edda;
            --loss: #f8d7da;
            --draw: #fff3cd;
            --upcoming: #e2e3e5;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        
        body {
            background-color: var(--light-bg);
            color: var(--text);
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        /* Header styles */
        header {
            display: flex;
            align-items: center;
            padding: 1rem;
            background-color: var(--primary); /* Use primary color from the main site */
            color: white;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 80px;
        }
        
        .header-logo {
            height: 60px;
            margin-right: 1rem;
        }
        
        .header-text {
            flex-grow: 1;
        }
        
        .header-text h1 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .header-text p {
            margin: 0;
            font-size: 1rem;
            opacity: 0.8;
        }
        
        /* Hamburger menu */
        .hamburger-menu {
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
        }
        
        .hamburger-menu:hover {
            opacity: 0.8;
        }
        
        /* Sidebar styles */
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 998;
            display: none;
        }
        
        .sidebar-overlay.active {
            display: block;
        }
        
        .sidebar {
            position: fixed;
            top: 80px; /* Height of header */
            left: -300px;
            width: 300px;
            height: calc(100vh - 80px);
            background-color: var(--light-bg); /* Use light background color from the main site */
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            z-index: 999;
            transition: transform 0.3s ease-in-out;
            overflow-y: auto;
            }
            
        .sidebar.active {
            transform: translateX(300px);
        }
        
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }
        
        .sidebar-header h2 {
            margin: 0 0 1rem 0;
            font-size: 1.25rem;
            color: var(--primary); /* Use primary color for headings */
        }
        
        .team-selector {
            width: 100%;
            margin-bottom: 1rem;
        }
        
        #sidebarTeamFilter {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background-color: white;
            font-size: 0.95rem;
        }
        
        .team-stats {
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .team-stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .team-stat-item:last-child {
            border-bottom: none;
        }
        
        .team-stat-label {
            color: var(--light-text);
            font-size: 0.9rem;
        }
        
        .team-stat-value {
            font-weight: 600;
        }
        
        .team-stat-value.win {
            color: #28a745; /* Green for wins */
            background-color: #d4edda; /* Light green background */
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .team-stat-value.loss {
            color: #dc3545; /* Red for losses */
            background-color: #f8d7da; /* Light red background */
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .team-stat-value.draw {
            color: #ffc107; /* Yellow for draws */
            background-color: #fff3cd; /* Light yellow background */
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .team-upcoming {
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 1.5rem;
        }
        
        .team-upcoming h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
            padding-bottom: 0.5rem;
        }
        
        .upcoming-match {
            padding: 0.75rem;
            background-color: var(--light-bg);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .upcoming-match-date {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }
        
        .upcoming-match-teams {
            font-size: 0.9rem;
        }
        
        .upcoming-match-venue {
            font-size: 0.85rem;
            color: var(--light-text);
            margin-top: 0.25rem;
        }
        
        /* Main content layout */
            .main-content {
            margin-top: 80px;
            min-height: calc(100vh - 80px);
            transition: margin-left 0.3s ease-in-out;
            }
            
        .content-area {
            padding: 1rem;
            transition: margin-left 0.3s ease-in-out;
            }
            
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .header-text h1 {
                font-size: 1.25rem;
            }
            
            .header-text p {
                font-size: 0.875rem;
            }
            
            .header-logo {
                height: 50px;
            }
            
            .sidebar {
                left: -300px;
            }
            
            .sidebar.active {
                transform: translateX(300px);
            }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .controls {
            position: fixed;
            top: 50px;
            width: 90%;
            left: 5%;
            z-index: 1000;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            border-radius: 8px;
            max-height: 90vh;
            overflow-y: auto;
            transform: translateY(0);
        }

        .controls-toggle {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 11;
        }

        .controls-toggle:hover {
            background: var(--primary-dark);
            transform: translateY(-50%) scale(1.1);
        }

        .controls-toggle i {
            transition: transform 0.3s ease;
        }

        .controls.collapsed .controls-toggle i {
            transform: rotate(180deg);
        }

        .controls.collapsed {
            padding: 0.5rem;
            max-height: 60px;
            overflow: hidden;
        }

        .controls.collapsed .filter-row {
            margin-bottom: 0;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .controls .filter-row {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .controls.collapsed .search-container {
            max-width: 200px;
        }

        .controls.collapsed select {
            padding: 0.5rem;
        }

        .controls.collapsed .date-range {
            display: none;
        }

        .controls.collapsed .filter-row > * {
            margin-bottom: 0;
        }

        @media (max-width: 768px) {
            .controls.collapsed .search-container {
                max-width: 100%;
            }
            
            .controls-toggle {
                position: static;
                transform: none;
                margin-left: 1rem;
            }
            
            .controls.collapsed .controls-toggle {
                margin-left: 0.5rem;
            }
        }
        
        .search-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        
        .search-group {
            flex: 1;
            position: relative;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .search-input-wrapper {
            position: relative;
            flex: 1;
        }
        
        .search-input-wrapper input {
            width: 100%;
            padding: 0.5rem;
            padding-left: 2rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 0.95rem;
        }
        
        .search-input-wrapper i {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--light-text);
        }
        
        .date-range-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .date-range-input {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 0.95rem;
            min-width: 200px;
        }
        
        .reset-btn {
            background-color: var(--light-bg);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        
        .reset-btn:hover {
            background-color: var(--border);
        }
        
        .reset-btn i {
            font-size: 0.9rem;
        }
        
        .calendar-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
        }
        
        .calendar-btn:hover {
            background-color: #005200;
        }
        
        .calendar-btn i {
            font-size: 1.1rem;
        }
        
        /* Add styles for the calendar popup */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            overflow-y: auto;
        }
        
        .calendar-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 90%;
            width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .calendar-popup h3 {
            margin-bottom: 1rem;
            color: var(--primary);
        }
        
        .calendar-popup .close-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--light-text);
        }
        
        .calendar-popup .actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .calendar-popup button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
        }
        
        .calendar-popup .cancel-btn {
            background: var(--light-bg);
            border: 1px solid var(--border);
        }
        
        .calendar-popup .save-btn {
            background: var(--primary);
            color: white;
            border: none;
        }
        
        .calendar-popup .matches-list {
            max-height: 50vh;
            overflow-y: auto;
            margin: 1rem 0;
            padding-right: 0.5rem;
        }
        
        .calendar-popup .match-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .calendar-popup .match-item:last-child {
            border-bottom: none;
        }
        
        .calendar-popup .match-item label {
            flex: 1;
            cursor: pointer;
        }
        
        .calendar-popup input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        body.popup-open {
            overflow: hidden;
        }
        
        .filter-row {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .filter-group {
            flex: 1;
            min-width: 200px;
            max-width: calc(33.333% - 1rem);
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .filter-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: var(--light-text);
        }
        
        .select-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            width: 100%;
        }
        
        .filter-group select {
            flex: 1;
            min-width: 0;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            background-color: white;
            font-size: 0.95rem;
        }
        
        .match-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .date-header {
            background-color: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .match-card {
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .match-card.win {
            border-left: 5px solid green;
        }
        
        .match-card.loss {
            border-left: 5px solid red;
        }
        
        .match-card.draw {
            border-left: 5px solid orange;
        }
        
        .match-card.upcoming {
            border-left: 5px solid gray;
        }
        
        .match-header {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background-color: rgba(0,0,0,0.03);
            border-bottom: 1px solid var(--border);
        }
        
        .competition {
            font-weight: 600;
        }
        
        .match-info {
            display: flex;
            font-size: 0.85rem;
            color: var(--light-text);
            gap: 1rem;
        }
        
        .match-content {
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .teams {
            display: flex;
            align-items: center;
            flex: 1;
        }
        
        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        .team-name {
            font-weight: 500;
            margin-top: 0.25rem;
        }
        
        .score-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin: 0 1rem;
        }
        
        .score {
            background-color: var(--light-bg);
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
        }
        
        .vs {
            font-size: 0.8rem;
            color: var(--light-text);
        }
        
        .metadata {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            font-size: 0.85rem;
            color: var(--light-text);
        }
        
        .venue {
            font-weight: 500;
        }
        
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-top: 0.5rem;
        }
        
        .badge.win {
            background-color: var(--win);
            color: #155724;
        }
        
        .badge.loss {
            background-color: var(--loss);
            color: #721c24;
        }
        
        .badge.draw {
            background-color: var(--draw);
            color: #856404;
        }
        
        .badge.upcoming {
            background-color: var(--upcoming);
            color: #383d41;
        }
        
        .no-results {
            background-color: white;
            padding: 3rem 1rem;
            text-align: center;
            border-radius: 0.5rem;
            color: var(--light-text);
        }
        
        .no-results p {
            margin-bottom: 1rem;
        }
        
        @media (max-width: 768px) {
            .filter-group {
                min-width: 100%;
                max-width: 100%;
            }
            
            .search-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .search-group {
                width: 100%;
            }
            
            .date-range-group {
                width: 100%;
            }
            
            .date-range-input {
                flex: 1;
                min-width: 0;
            }
            
            .match-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .teams {
                width: 100%;
                justify-content: space-between;
            }
            
            .metadata {
                width: 100%;
                align-items: center;
                border-top: 1px solid var(--border);
                padding-top: 1rem;
            }
        }
        
        .stats-container {
            background-color: white;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        .stat-card {
            background-color: var(--light-bg);
            padding: 1rem;
            border-radius: 0.25rem;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: var(--light-text);
        }
        
        .stat-card.win {
            border-left: 4px solid var(--win);
        }
        
        .stat-card.loss {
            border-left: 4px solid var(--loss);
        }
        
        .stat-card.draw {
            border-left: 4px solid var(--draw);
        }
        
        .stat-card.upcoming {
            border-left: 4px solid var(--upcoming);
        }
        
        .share-btn {
            background-color: var(--secondary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }
        
        .share-btn:hover {
            background-color: #e67e00;
        }
        
        .share-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 90%;
            width: 400px;
        }
        
        .share-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .share-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .share-option:hover {
            background-color: var(--light-bg);
        }
        
        .share-option i {
            font-size: 1.2rem;
            width: 24px;
            text-align: center;
        }
        
        .share-option.whatsapp i {
            color: #25D366;
        }
        
        .share-option.email i {
            color: var(--primary);
        }
        
        .share-option.copy i {
            color: var(--secondary);
        }
        
        .share-url {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .share-url input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 0.95rem;
        }
        
        /* Add styles for today marker */
        .today-marker {
            position: relative;
            text-align: center;
            padding: 10px 0;
            margin: 10px 0;
            background: var(--primary);
            color: white;
            border-radius: 4px;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0,100,0,0.4);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 rgba(0,100,0,0.4); }
            50% { box-shadow: 0 0 15px rgba(0,100,0,0.8); }
            100% { box-shadow: 0 0 0 rgba(0,100,0,0.4); }
        }
        
        .today-marker span {
            background: white;
            color: var(--primary);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.9em;
        }
        
        /* Add styles for the team category */
        .match-header-main {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .team-category {
            font-size: 1rem;
            color: var(--primary);
            font-weight: 600;
        }
        
        .competition {
            font-size: 0.9rem;
            color: var(--light-text);
            font-weight: 500;
        }
        
        /* Add styles for autocomplete */
        .search-input-wrapper {
            position: relative;
            flex: 1;
        }
        
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .autocomplete-suggestion {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
        }
        
        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }
        
        .autocomplete-suggestion:hover {
            background-color: var(--light-bg);
        }
        
        .autocomplete-suggestion.active {
            background-color: var(--light-bg);
        }
        
        .sidebar .upcoming-matches {
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .sidebar .upcoming-matches h3 {
            color: var(--primary);
            margin-bottom: 1rem;
            font-size: 1rem;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 0.5rem;
        }
        
        .sidebar .upcoming-match {
            padding: 0.75rem;
            background: var(--light-bg);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .sidebar .upcoming-match .match-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        
        .sidebar .upcoming-match .match-time {
            color: var(--primary);
            font-weight: 600;
            white-space: nowrap;
            min-width: 70px;
        }
        
        .sidebar .upcoming-match .team-category {
            color: var(--text);
            font-weight: 500;
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .sidebar .upcoming-match .match-details {
            color: var(--light-text);
            font-size: 0.85rem;
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sidebar.collapsed .upcoming-match .match-header {
            margin-bottom: 2px;
        }
        
        .sidebar.collapsed .upcoming-match {
            padding: 0.5rem;
        }
        
        .filters {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 10;
            margin: 0 0 1rem 0;
        }
        
        .filters select {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: white;
            min-width: 150px;
            font-size: 0.9rem;
        }
        
        .filters select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(0, 100, 0, 0.1);
        }
        
        @media (max-width: 768px) {
            .filters {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.75rem;
            }
            
            .filters select {
                width: 100%;
            }
        }

        /* Add to Home Screen prompt styles */
        .add-to-home {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 1000;
            text-align: center;
        }

        .add-to-home.show {
            display: block;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
            }
            to {
                transform: translate(-50%, 0);
            }
        }

        .add-to-home button {
            margin: 0.5rem;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .add-to-home .install-btn {
            background: var(--primary);
            color: white;
        }

        .add-to-home .close-btn {
            background: var(--light-bg);
            color: var(--text);
        }

        /* Notification permission prompt styles */
        .notification-prompt {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            z-index: 1000;
            max-width: 300px;
        }

        .notification-prompt.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
            }
            to {
                transform: translateX(0);
            }
        }

        .notification-prompt button {
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        .notification-prompt .allow-btn {
            background: var(--primary);
            color: white;
            margin-bottom: 0.5rem;
        }

        .notification-prompt .deny-btn {
            background: var(--light-bg);
            color: var(--text);
        }
        
        /* Add training event styles */
        .match-card.training {
            background-color: #f0f8ff;
            border-left: 5px solid #4285f4;
        }
        
        .badge.training {
            background-color: #4285f4;
            color: white;
        }

        .match-card.training {
            border-left: 4px solid #4a90e2;
        }
        
        .match-card.training .badge.training {
            background-color: #4a90e2;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .match-card.training .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .match-card.training .team {
            font-weight: bold;
        }

        .match-card.training .description {
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
            white-space: pre-line;
        }

        .toggle-group {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
        }

        .toggle-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .toggle-text {
            font-size: 0.9rem;
            color: var(--text);
        }

        .filter-row {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        /* Match statistics header styling */
        .team-stats h3 {
            font-size: 1rem;
            margin-bottom: 0.75rem;
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
            padding-bottom: 0.5rem;
        }

        /* Color styling for icons in statistics */
        .team-stat-item i.stat-icon {
            margin-right: 0.5rem;
            font-size: 1.2rem;
            color: var(--primary); /* Use primary color for all icons */
        }

        .team-stat-item i.stat-icon.win {
            color: #28a745; /* Green for wins */
        }

        .team-stat-item i.stat-icon.loss {
            color: #dc3545; /* Red for losses */
        }

        .team-stat-item i.stat-icon.draw {
            color: #ffc107; /* Yellow for draws */
        }

        .team-stat-item i.stat-icon.upcoming {
            color: #17a2b8; /* Blue for upcoming matches */
        }

        /* Add CSS class for hidden state */
        .hidden {
            display: none;
        }

        #scrollToTodayBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            display: none;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
            font-size: 0.9rem;
            transition: opacity 0.3s ease;
        }

        #scrollToTodayBtn:hover {
            background: #004d00; /* Optional hover effect */
        }
    </style>
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Add Flatpickr for date picking -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <!-- Add these scripts after your existing scripts -->
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
</head>
<body>
    <header>
        <button id="hamburgerMenu" class="hamburger-menu">
            <i class="fas fa-bars"></i>
        </button>
        <img src="/assets/IMG_9120-WHITE.png" alt="Grange Naomh Colmcille CLG Logo" class="header-logo">
        <div class="header-text">
        <h1>Grange Naomh Colmcille CLG</h1>
            <p>Fixtures & Results 2025</p>
        </div>
        <button id="filterToggle" class="filter-toggle">
            <i class="fas fa-chevron-down"></i>
        </button>
    </header>
    
    <div class="main-content">
        <div class="sidebar-overlay"></div>
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Team Statistics</h2>
                <div class="team-selector">
                    <select id="sidebarTeamFilter">
                        <option value="all">All Teams</option>
                    </select>
                </div>
            </div>
            
            <div class="team-stats">
                <h3>Match Statistics</h3>
                <div class="team-stat-item">
                    <i class="fas fa-trophy stat-icon"></i>
                    <span class="team-stat-label">Total Matches</span>
                    <span class="team-stat-value" id="sidebarTotalCount">0</span>
                </div>
                <div class="team-stat-item">
                    <i class="fas fa-check-circle stat-icon"></i>
                    <span class="team-stat-label">Wins</span>
                    <span class="team-stat-value win" id="sidebarWinCount">0</span>
                </div>
                <div class="team-stat-item">
                    <i class="fas fa-times-circle stat-icon"></i>
                    <span class="team-stat-label">Losses</span>
                    <span class="team-stat-value loss" id="sidebarLossCount">0</span>
                </div>
                <div class="team-stat-item">
                    <i class="fas fa-minus-circle stat-icon"></i>
                    <span class="team-stat-label">Draws</span>
                    <span class="team-stat-value draw" id="sidebarDrawCount">0</span>
                </div>
                <div class="team-stat-item">
                    <i class="fas fa-calendar-alt stat-icon"></i>
                    <span class="team-stat-label">Upcoming Matches</span>
                    <span class="team-stat-value" id="sidebarUpcomingCount">0</span>
                </div>
            </div>
            
            <div class="team-upcoming">
                <h3>Next 3 Upcoming Matches</h3>
                <div id="upcomingMatchesList">
                    <!-- Upcoming matches will be populated here -->
                </div>
            </div>
            
            <div class="team-upcoming">
                <h3>Next 3 Training Sessions</h3>
                <div id="upcomingTrainingList">
                    <!-- Upcoming training sessions will be populated here -->
                </div>
            </div>
        </div>
        
        <div class="content-area">
        <div class="controls">
                <div class="search-row">
                    <div class="search-group">
                        <div class="search-input-wrapper">
                            <i class="fas fa-search"></i>
                        <input type="text" id="searchInput" placeholder="Search matches, teams or competitions...">
                        </div>
                        <button class="reset-btn" id="resetSearch" title="Reset search">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="date-range-group">
                        <input type="text" id="dateRange" class="date-range-input" placeholder="Select date range">
                        <button class="reset-btn" id="resetDate" title="Reset date range">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="filter-row">
                    <div class="filter-group">
                        <label>Show:</label>
                        <div class="toggle-group">
                            <label class="toggle-label">
                                <input type="checkbox" id="showMatches" checked>
                                <span class="toggle-text">Matches</span>
                            </label>
                            <label class="toggle-label">
                                <input type="checkbox" id="showTraining" checked>
                                <span class="toggle-text">Training</span>
                            </label>
                        </div>
                    </div>
                </div>
        </div>
        
        <div id="matchContainer" class="match-list">
            <!-- Matches will be populated here -->
            </div>
        </div>
    </div>
    
    <div class="add-to-home">
        <p>Add this app to your home screen for quick access!</p>
        <button class="install-btn">Install</button>
        <button class="close-btn">Maybe Later</button>
    </div>

    <div class="notification-prompt">
        <p>Get notified about upcoming matches!</p>
        <button class="allow-btn">Allow Notifications</button>
        <button class="deny-btn">No Thanks</button>
    </div>
    
    <div id="filterAlert" style="position: fixed; top: 25px; left: 50%; transform: translateX(-50%); background-color: #f8f9fa; color: #333; padding: 8px 15px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); z-index: 1001; transition: opacity 0.3s ease; display: none;">
        <div style="display: flex; align-items: center; gap: 10px;">
            <span>A Filter is applied!</span>
            <button id="clearFiltersBtn" class="reset-btn" style="background-color: var(--light-bg); color: var(--text); border: 1px solid var(--border); padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.95rem; display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; transition: all 0.2s ease; flex-shrink: 0;">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <script>
        // Parse the CSV data and store it in a global variable
        let matches = [];
        
        // Function to format date in a more readable format
        function formatDate(dateStr) {
            console.log('Formatting date:', dateStr);
            if (typeof dateStr === 'string') {
                dateStr = parseDate(dateStr);
            }
            const formatted = dateStr.toLocaleDateString('en-GB', {
                weekday: 'short',
                day: 'numeric',
                month: 'short',
                year: '2-digit'
            }).replace(/,/g, '');
            //console.log('Formatted date:', formatted);
            return formatted;
        }
        
        // Extract unique teams, competitions for filters
        function extractFilterOptions() {
            console.log('Extracting filter options...');
            const teams = new Set();
            const competitions = new Map(); // Changed to Map to store sex with competition
            
            matches.forEach(match => {
                if (match.Team) teams.add(match.Team);
                if (match.Competition) {
                    // Store competition with its sex category
                    competitions.set(match.Competition, match.Sex);
                }
            });
            
            const options = {
                teams: Array.from(teams).sort(),
                competitions: Array.from(competitions.entries())
                    .sort((a, b) => {
                        // First sort by sex
                        const sexOrder = { 'Men': 1, 'Ladies': 2, 'Boys': 3, 'Girls': 4 };
                        const sexA = sexOrder[a[1]] || 999;
                        const sexB = sexOrder[b[1]] || 999;
                        if (sexA !== sexB) return sexA - sexB;
                        // Then sort by competition name
                        return a[0].localeCompare(b[0]);
                    })
            };
            
            console.log('Filter options:', options);
            return options;
        }
        
        // Populate filter dropdowns
        function populateFilters(options) {
            console.log('Populating filters...');
            const teamFilter = document.getElementById('teamFilter');
            const competitionFilter = document.getElementById('competitionFilter');
            
            // Clear existing options except the first one
            while (teamFilter.options.length > 1) {
                teamFilter.remove(1);
            }
            while (competitionFilter.options.length > 1) {
                competitionFilter.remove(1);
            }
            
            options.teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamFilter.appendChild(option);
            });
            
            options.competitions.forEach(([competition, sex]) => {
                const option = document.createElement('option');
                option.value = competition;
                // Format the display text with sex category
                option.textContent = `${sex} - ${competition}`;
                competitionFilter.appendChild(option);
            });
        }
        
        /*
        // Function to update statistics
        function updateStats(matches) {
            const stats = {
                wins: 0,
                losses: 0,
                draws: 0,
                upcoming: 0
            };
            
            matches.forEach(match => {
                if (match.Result === 'WIN') stats.wins++;
                else if (match.Result === 'LOSS') stats.losses++;
                else if (match.Result === 'DRAW') stats.draws++;
                else if (match.Result === '---' || !match.Result) stats.upcoming++;
            });
            
            document.getElementById('winCount').textContent = stats.wins;
            document.getElementById('lossCount').textContent = stats.losses;
            document.getElementById('drawCount').textContent = stats.draws;
            document.getElementById('upcomingCount').textContent = stats.upcoming;
        }
        */
        
        // Group matches by date
        function groupMatchesByDate(matches) {
            console.log('Starting groupMatchesByDate with matches:', matches);
            const groupedMatches = {};
            const processedIds = new Set();
            
            matches.forEach(match => {
                // Format date consistently
                const date = formatDate(match.Date);
                console.log(`Processing match: ${match.Team} on ${date} (original date: ${match.Date})`);
                
                if (!groupedMatches[date]) {
                    groupedMatches[date] = {
                        matches: [],
                        training: []
                    };
                    console.log(`Created new date group for: ${date}`);
                }
                
                // For training events, use the ID to check for duplicates
                // For regular matches, use the combination of date, time, and team
                const matchId = match.isTraining ? 
                    match['Fixture ID'] : 
                    `${date}-${match.Time || '00:00'}-${match.Team}`;
                
                if (!processedIds.has(matchId)) {
                    processedIds.add(matchId);
                    if (match.isTraining) {
                        groupedMatches[date].training.push(match);
                    } else {
                        groupedMatches[date].matches.push(match);
                    }
                    console.log(`Added ${match.isTraining ? 'training event' : 'match'} to group ${date}: ${match.Team} at ${match.Time}`);
                } else {
                    console.log(`Skipped duplicate ${match.isTraining ? 'training event' : 'match'}: ${match.Team} at ${match.Time}`);
                }
            });
            
            console.log('Final grouped matches:', groupedMatches);
            
            // Sort matches and training events within each date group by time
            Object.keys(groupedMatches).forEach(date => {
                groupedMatches[date].matches.sort((a, b) => {
                    const timeA = a.Time || '00:00';
                    const timeB = b.Time || '00:00';
                    return timeA.localeCompare(timeB);
                });
                groupedMatches[date].training.sort((a, b) => {
                    const timeA = a.Time || '00:00';
                    const timeB = b.Time || '00:00';
                    return timeA.localeCompare(timeB);
                });
                console.log(`Sorted matches and training for ${date}:`, groupedMatches[date]);
            });
            
            return groupedMatches;
        }
        
        // Enhanced display matches function
        function displayMatches() {
            console.log('Displaying matches...');
            const filteredMatches = filterMatches();
            const matchContainer = document.getElementById('matchContainer');
            matchContainer.innerHTML = '';
            
            if (filteredMatches.length === 0) {
                matchContainer.innerHTML = `
                    <div class="no-results">
                        <p>No matches found for the selected filters.</p>
                        <p>Try changing your filter options.</p>
                    </div>
                `;
                return;
            }
            
            // Group matches by date
            const groupedMatches = groupMatchesByDate(filteredMatches);
            
            // Sort dates chronologically
            const sortedDates = Object.keys(groupedMatches).sort((a, b) => {
                const dateA = parseDate(a);
                const dateB = parseDate(b);
                return dateA - dateB;
            });
            
            // Get today's date for comparison
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            console.log('Today:', today);
            let todayMarkerInserted = false;
            
            // Loop through dates and matches
            sortedDates.forEach(date => {
                const currentDate = parseDate(date);
                console.log('Checking date:', currentDate);
                
                // Insert the today marker before today's matches
                if (currentDate.toDateString() === today.toDateString() && !todayMarkerInserted) {
                    console.log('Inserting today marker for date:', currentDate);
                    const todayMarker = document.createElement('div');
                    todayMarker.className = 'today-marker';
                    todayMarker.innerHTML = '<span>Today</span>';
                    todayMarker.id = 'todayMarker';
                    matchContainer.appendChild(todayMarker);
                    todayMarkerInserted = true;
                }
                
                const dateHeader = document.createElement('div');
                dateHeader.className = 'date-header';
                dateHeader.textContent = formatDate(date);
                matchContainer.appendChild(dateHeader);
                
                // Display matches for this date
                groupedMatches[date].matches.forEach(match => {
                    const matchCard = createMatchCard(match);
                    matchContainer.appendChild(matchCard);
                });
                
                // Display training events for this date
                groupedMatches[date].training.forEach(match => {
                    const matchCard = createMatchCard(match);
                    matchContainer.appendChild(matchCard);
                });
            });
            
            // Scroll to today marker after a brief delay to ensure DOM is updated
            setTimeout(() => {
                const todayMarker = document.getElementById('todayMarker');
                if (todayMarker) {
                    console.log('Scrolling to today marker');
                    todayMarker.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                } else {
                    console.log('Today marker not found');
                }
            }, 300);
            
            console.log('Matches displayed:', filteredMatches.length);
        }
        
        // Initialize the application
        async function init() {
            console.log('=== init START ===');
            try {
                // Initialize empty matches array
                matches = [];
                console.log('Initialized empty matches array');
                
                // Wait for DOM to be fully loaded
                if (document.readyState === 'loading') {
                    console.log('DOM not fully loaded, waiting...');
                    await new Promise(resolve => {
                        document.addEventListener('DOMContentLoaded', resolve);
                    });
                    console.log('DOM fully loaded');
                }
                
                // Fetch matches from worker
                console.log('Starting to fetch matches from worker...');
                const workerMatches = await fetchMatchesFromWorker();
                console.log('Worker matches fetched:', workerMatches.length);
                matches = workerMatches; // Replace instead of concat
                
                // Fetch training events
                console.log('Starting to fetch training events...');
                await fetchTrainingEvents();
                console.log('Training events fetched, total matches now:', matches.length);
                
                // Initialize UI after data is loaded
                console.log('Initializing UI...');
                initializeUI();
                
                // Initialize search functionality
                console.log('Initializing search functionality...');
                initSearchAutocomplete();
                
                console.log('Initialization complete. Final match count:', matches.length);
                
            } catch (error) {
                console.error('Error in init:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('matchContainer').innerHTML = `
                    <div class="no-results">
                        <p>Error loading matches. Please try refreshing the page.</p>
                        <p>Error details: ${error.message}</p>
                    </div>
                `;
            }
            console.log('=== init END ===');
        }
        
        // Separate UI initialization
        function initializeUI() {
            try {
                console.log('Initializing UI...');
                
                // Initialize date picker
                flatpickr("#dateRange", {
                    mode: "range",
                    dateFormat: "D M d Y",
                    onChange: function(selectedDates, dateStr, instance) {
                        console.log('Date changed:', selectedDates);
                        displayMatches();
                        updateFilterAlert();
                    },
                    onClose: function(selectedDates, dateStr, instance) {
                        console.log('Date picker closed:', selectedDates);
                        updateFilterAlert();
                    }
                });
                
                // Initialize sidebar
                initSidebarToggle();
                
                // Display initial matches
                displayMatches();
                
                console.log('UI initialization complete');
            } catch (error) {
                console.error('Error initializing UI:', error);
                throw error;
            }
        }
        
        // Debounce function to limit search input processing
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Enhanced filter matches function to include search and date range
        function filterMatches() {
            console.log('=== filterMatches START ===');
            const searchInput = document.getElementById('searchInput');
            const showMatches = document.getElementById('showMatches').checked;
            const showTraining = document.getElementById('showTraining').checked;
            
            console.log('Filter settings:', { showMatches, showTraining });
            
            if (!searchInput) {
                console.error('Search input element not found!');
                return matches;
            }
            
            const searchQuery = (searchInput.value || '').toLowerCase().trim();
            console.log('Current search query:', searchQuery);
            
            // Get date range safely
            let dateRange = null;
            const dateRangeInput = document.getElementById('dateRange');
            console.log('Date range input element:', dateRangeInput);
            
            if (dateRangeInput && dateRangeInput._flatpickr && dateRangeInput._flatpickr.selectedDates.length > 0) {
                dateRange = dateRangeInput._flatpickr.selectedDates;
                console.log('Selected date range:', dateRange);
            }
            
            console.log('Total matches before filtering:', matches.length);
            
            // First apply type filters (matches/training)
            let filteredMatches = matches.filter(match => {
                if (!showMatches && !match.isTraining) return false;
                if (!showTraining && match.isTraining) return false;
                return true;
            });
                
            console.log('Matches after type filtering:', filteredMatches.length);
            
            // Then apply search filter if there's a search query
                if (searchQuery) {
                filteredMatches = filteredMatches.filter(match => {
                    const searchableText = [
                        match.Competition || '',
                        match.Team || '',
                        match['Home Team'] || '',
                        match['Away Team'] || '',
                        match.Venue || '',
                        match.Round || '',
                        match.Date || '',
                        match.Time || ''
                    ].join(' ').toLowerCase();
                    
                    return searchableText.includes(searchQuery);
                    });
                console.log('Matches after search filtering:', filteredMatches.length);
                }
                
            // Finally apply date range filter if selected
                if (dateRange && dateRange.length === 2) {
                filteredMatches = filteredMatches.filter(match => {
                    const matchDate = parseDate(match.Date);
                    const startDate = dateRange[0];
                    const endDate = dateRange[1];
                    
                    return matchDate >= startDate && matchDate <= endDate;
                });
                console.log('Matches after date range filtering:', filteredMatches.length);
            }
            
            console.log('Total matches after all filtering:', filteredMatches.length);
            console.log('=== filterMatches END ===');
            return filteredMatches;
        }
        
        // Helper function to parse date strings
        function parseDate(dateStr) {
            console.log('Parsing date string:', dateStr);
            
            // Check if the date is in the format "Mon 31 Mar 25"
            const formatOne = /^[A-Za-z]{3} \d{1,2} [A-Za-z]{3} \d{2}$/;
            if (formatOne.test(dateStr)) {
                const parts = dateStr.split(' ');
                const day = parseInt(parts[1]);
                const month = getMonthNumber(parts[2]);
                const year = 2000 + parseInt(parts[3]);
                const date = new Date(year, month, day);
                console.log('Parsed date (format one):', date);
                return date;
            }
            
            // Otherwise, assume it's a standard date string
            const date = new Date(dateStr);
            console.log('Parsed date (standard):', date);
            return date;
        }
        
        function getMonthNumber(monthStr) {
            const months = {
                'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5,
                'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11
            };
            return months[monthStr];
        }
        
        // Helper to create a <span> only if value exists : used in createMatchCard()
        function createSpanIfValue(className, label, value) {
            if (!value) return null;
            const span = document.createElement('span');
            span.className = className;
            if (label) {
            span.textContent = `${label}: ${value}`;
            } else {
                span.textContent = `${value}` || '';
            }
            return span;
        }
        
        // Create a match card element
        function createMatchCard(match) {
            const matchCard = document.createElement('div');
            matchCard.className = 'match-card';
            
            // Add result class if available
            if (match.Result && match.Result !== '---') {
                matchCard.classList.add(match.Result.toLowerCase());
            } else {
                matchCard.classList.add('upcoming');
            }
            
            // Create all elements first
            const matchHeader = document.createElement('div');
            matchHeader.className = 'match-header';
            
            const matchHeaderMain = document.createElement('div');
            matchHeaderMain.className = 'match-header-main';
            
            const teamCategory = document.createElement('span');
            teamCategory.className = 'team-category';
            teamCategory.textContent = match.Team || '';
            
            const competition = document.createElement('span');
            competition.className = 'competition';
            competition.textContent = match.Competition || '';
            
            const matchInfo = document.createElement('div');
            matchInfo.className = 'match-info';
            
            const round = document.createElement('span');
            round.textContent = match.Round || '';
            
            const sex = document.createElement('span');
            sex.textContent = match.Sex || '';
            
            const matchContent = document.createElement('div');
            matchContent.className = 'match-content';
            
            const teams = document.createElement('div');
            teams.className = 'teams';
            
            const homeTeam = document.createElement('div');
            homeTeam.className = 'team';
            
            const homeTeamName = document.createElement('div');
            homeTeamName.className = 'team-name';
            homeTeamName.textContent = match['Home Team'] || '';
            
            const scoreContainer = document.createElement('div');
            scoreContainer.className = 'score-container';
            
            const awayTeam = document.createElement('div');
            awayTeam.className = 'team';
            
            const awayTeamName = document.createElement('div');
            awayTeamName.className = 'team-name';
            awayTeamName.textContent = match['Away Team'] || '';
            
            const metadata = document.createElement('div');
            metadata.className = 'metadata';
            const metaTop = document.createElement('div');
            metaTop.className = 'meta-top';
            const metaBottom = document.createElement('div');
            metaBottom.className = 'meta-bottom';
            
            // Add venue if it exists
            if (match.Venue) {
                const venue = createSpanIfValue('venue', 'Venue', match.Venue);
                metaTop.appendChild(venue);
            }

            // Add a separator @ ONLY if both venue AND time exist
            if (match.Venue && match.Time) {
                const separator = document.createElement('span');
                separator.className = 'separator';
                separator.textContent = ' @ ';
                metaTop.appendChild(separator);
            }

            // Add time if it exists
            if (match.Time) {
                const time = createSpanIfValue('time', '', match.Time);
                metaTop.appendChild(time);
            }
            
            // Add referee if it exists
            if (match.Referee) {
                const referee = createSpanIfValue('referee', 'Referee', match.Referee);
                metaBottom.appendChild(referee);
            }

            // Append to metadata
            metadata.appendChild(metaTop);
            metadata.appendChild(metaBottom);

            // Assemble the elements
            matchHeaderMain.appendChild(teamCategory);
            matchHeaderMain.appendChild(competition);
            matchInfo.appendChild(round);
            matchInfo.appendChild(sex);
            matchHeader.appendChild(matchHeaderMain);
            matchHeader.appendChild(matchInfo);
            
            homeTeam.appendChild(homeTeamName);
            awayTeam.appendChild(awayTeamName);
            
            // Add scores or vs text
            if (match.Result && match.Result !== '---' && 
                match['Home Score'] && match['Home Score'] !== '---' && 
                match['Away Score'] && match['Away Score'] !== '---') {
                const homeScore = document.createElement('span');
                homeScore.className = 'score';
                homeScore.textContent = match['Home Score'];
                
                const awayScore = document.createElement('span');
                awayScore.className = 'score';
                awayScore.textContent = match['Away Score'];
                
                scoreContainer.appendChild(homeScore);
                scoreContainer.appendChild(awayScore);
            } else {
                const vs = document.createElement('span');
                vs.className = 'vs';
                vs.textContent = 'vs';
                scoreContainer.appendChild(vs);
            }
            
            teams.appendChild(homeTeam);
            teams.appendChild(scoreContainer);
            teams.appendChild(awayTeam);
            

            if (match.Result && match.Result !== '---') {
                const badge = document.createElement('span');
                badge.className = `badge ${match.Result.toLowerCase()}`;
                badge.textContent = match.Result;
                metadata.appendChild(badge);
            }
            
            matchContent.appendChild(teams);
            matchContent.appendChild(metadata);
            matchCard.appendChild(matchHeader);
            matchCard.appendChild(matchContent);
            
            return matchCard;
        }
        
        // Calendar integration functions
        function showCalendarPopup() {
            const filteredMatches = filterMatches();
            if (filteredMatches.length === 0) {
                alert('No matches selected to add to calendar.');
                return;
            }
            
            // Prevent body scrolling
            document.body.classList.add('popup-open');
            
            const popup = document.createElement('div');
            popup.className = 'calendar-popup';
            popup.innerHTML = `
                <button class="close-btn">&times;</button>
                <h3>Add to Calendar</h3>
                <p>Select matches to add to your calendar:</p>
                <div class="matches-list">
                    ${filteredMatches.map(match => `
                        <div class="match-item">
                            <input type="checkbox" id="match-${match['Fixture ID']}" value="${match['Fixture ID']}">
                            <label for="match-${match['Fixture ID']}">
                                ${formatDate(match.Date)} - ${match.Competition}: ${match['Home Team']} vs ${match['Away Team']}
                            </label>
                        </div>
                    `).join('')}
                </div>
                <div class="actions">
                    <button class="cancel-btn">Cancel</button>
                    <button class="save-btn">Add to Calendar</button>
                </div>
            `;
            
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Event listeners for popup
            const closePopup = () => {
                document.body.removeChild(overlay);
                document.body.removeChild(popup);
                document.body.classList.remove('popup-open');
            };
            
            popup.querySelector('.close-btn').addEventListener('click', closePopup);
            popup.querySelector('.cancel-btn').addEventListener('click', closePopup);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closePopup();
                }
            });
            
            // Close on escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closePopup();
                }
            });
            
            popup.querySelector('.save-btn').addEventListener('click', () => {
                const selectedMatches = Array.from(popup.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(checkbox => matches.find(m => m['Fixture ID'] === checkbox.value));
                
                if (selectedMatches.length > 0) {
                    addToCalendar(selectedMatches);
                }
                
                closePopup();
            });
        }
        
        function addToCalendar(matches) {
            matches.forEach(match => {
                const event = {
                    title: `${match.Competition}: ${match['Home Team']} vs ${match['Away Team']}`,
                    start: `${match.Date} ${match.Time}`,
                    location: match.Venue,
                    description: `Round: ${match.Round}\nReferee: ${match.Referee || 'TBA'}`,
                    url: match['Fixture Src'] === 'url' ? `https://example.com/fixtures/${match['Fixture ID']}` : ''
                };
                
                // Generate calendar links
                const googleCalendarUrl = generateGoogleCalendarUrl(event);
                const outlookCalendarUrl = generateOutlookCalendarUrl(event);
                const icalContent = generateICalContent(event);
                
                // Create download link for .ics file
                const blob = new Blob([icalContent], { type: 'text/calendar;charset=utf-8' });
                const link = document.createElement('a');
                link.href = window.URL.createObjectURL(blob);
                link.download = `match-${match['Fixture ID']}.ics`;
                link.click();
                
                // Open calendar options in new window
                const calendarOptions = window.open('', '_blank');
                calendarOptions.document.write(`
                    <html>
                        <head>
                            <title>Add to Calendar</title>
                            <style>
                                body { font-family: Arial, sans-serif; padding: 20px; }
                                .button { 
                                    display: inline-block;
                                    padding: 10px 20px;
                                    margin: 5px;
                                    background-color: #006400;
                                    color: white;
                                    text-decoration: none;
                                    border-radius: 5px;
                                }
                            </style>
                        </head>
                        <body>
                            <h2>Add "${event.title}" to your calendar</h2>
                            <p>
                                <a href="${googleCalendarUrl}" class="button" target="_blank">Add to Google Calendar</a>
                                <a href="${outlookCalendarUrl}" class="button" target="_blank">Add to Outlook</a>
                            </p>
                            <p>The .ics file has been downloaded. You can import it into your calendar application.</p>
                        </body>
                    </html>
                `);
            });
        }
        
        function generateGoogleCalendarUrl(event) {
            const params = new URLSearchParams({
                action: 'TEMPLATE',
                text: event.title,
                dates: `${formatDateForGoogle(event.start)}/${formatDateForGoogle(event.start)}`,
                details: event.description,
                location: event.location,
                url: event.url
            });
            
            return `https://calendar.google.com/calendar/render?${params.toString()}`;
        }
        
        function generateOutlookCalendarUrl(event) {
            const params = new URLSearchParams({
                subject: event.title,
                startdt: event.start,
                enddt: event.start,
                body: event.description,
                location: event.location,
                url: event.url
            });
            
            return `https://outlook.live.com/calendar/0/deeplink/compose?${params.toString()}`;
        }
        
        function generateICalContent(event) {
            return `BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//Grange Naomh Colmcille CLG//Fixtures//EN
BEGIN:VEVENT
DTSTART:${formatDateForICal(event.start)}
DTEND:${formatDateForICal(event.start)}
SUMMARY:${event.title}
DESCRIPTION:${event.description}
LOCATION:${event.location}
URL:${event.url}
END:VEVENT
END:VCALENDAR`;
        }
        
        function formatDateForGoogle(dateStr) {
            const date = new Date(dateStr);
            return date.toISOString().replace(/-|:|\.\d+/g, '');
        }
        
        function formatDateForICal(dateStr) {
            const date = new Date(dateStr);
            return date.toISOString().replace(/-|:/g, '').split('.')[0] + 'Z';
        }
        
        // Share functionality
        function showSharePopup() {
            const filteredMatches = filterMatches();
            if (filteredMatches.length === 0) {
                alert('No matches to share.');
                return;
            }
            
            // Create share URL with current filters
            const shareUrl = new URL(window.location.href);
            const params = new URLSearchParams();
            
            if (document.getElementById('teamFilter').value !== 'all') {
                params.append('team', document.getElementById('teamFilter').value);
            }
            if (document.getElementById('competitionFilter').value !== 'all') {
                params.append('competition', document.getElementById('competitionFilter').value);
            }
            if (document.getElementById('statusFilter').value !== 'all') {
                params.append('status', document.getElementById('statusFilter').value);
            }
            if (document.getElementById('searchInput').value) {
                params.append('search', document.getElementById('searchInput').value);
            }
            
            const dateRange = document.getElementById('dateRange')._flatpickr.selectedDates;
            if (dateRange && dateRange.length === 2) {
                params.append('startDate', dateRange[0].toISOString().split('T')[0]);
                params.append('endDate', dateRange[1].toISOString().split('T')[0]);
            }
            
            shareUrl.search = params.toString();
            const shareUrlString = shareUrl.toString();
            
            // Create share text
            const shareText = `Check out these ${filteredMatches.length} matches from Grange Naomh Colmcille CLG!`;
            
            const popup = document.createElement('div');
            popup.className = 'share-popup';
            popup.innerHTML = `
                <button class="close-btn">&times;</button>
                <h3>Share Matches</h3>
                <div class="share-options">
                    <div class="share-option whatsapp" onclick="window.open('https://wa.me/?text=${encodeURIComponent(shareText + ' ' + shareUrlString)}')">
                        <i class="fab fa-whatsapp"></i>
                        Share on WhatsApp
                    </div>
                    <div class="share-option email" onclick="window.open('mailto:?subject=${encodeURIComponent('Grange Naomh Colmcille CLG Matches')}&body=${encodeURIComponent(shareText + '\n\n' + shareUrlString)}')">
                        <i class="fas fa-envelope"></i>
                        Share via Email
                    </div>
                    <div class="share-option copy" onclick="navigator.clipboard.writeText('${shareUrlString}')">
                        <i class="fas fa-link"></i>
                        Copy Link
                    </div>
                </div>
                <div class="share-url">
                    <input type="text" value="${shareUrlString}" readonly>
                    <button class="reset-btn" onclick="navigator.clipboard.writeText('${shareUrlString}')">
                        <i class="fas fa-copy"></i>
                    </button>
                </div>
            `;
            
            const overlay = document.createElement('div');
            overlay.className = 'overlay';
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Event listeners
            const closePopup = () => {
                document.body.removeChild(overlay);
                document.body.removeChild(popup);
            };
            
            popup.querySelector('.close-btn').addEventListener('click', closePopup);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closePopup();
            });
            
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') closePopup();
            });
        }

        // Add new function for upcoming training sessions
        function updateUpcomingTraining(teamName) {
            const teamMatches = teamName === 'all' 
                ? matches 
                : matches.filter(match => match.Team === teamName);
            
            // Filter upcoming training sessions
            const upcomingTraining = teamMatches
                .filter(match => match.isTraining)
                .sort((a, b) => parseDate(a.Date) - parseDate(b.Date))
                .slice(0, 3);
            
            const upcomingTrainingList = document.getElementById('upcomingTrainingList');
            upcomingTrainingList.innerHTML = '';
            
            if (upcomingTraining.length === 0) {
                upcomingTrainingList.innerHTML = '<p>No upcoming training sessions</p>';
                return;
            }
            
            upcomingTraining.forEach(session => {
                const sessionElement = document.createElement('div');
                sessionElement.className = 'upcoming-match';
                sessionElement.innerHTML = `
                    <div class="upcoming-match-date">${formatDate(session.Date)}</div>
                    <div class="upcoming-match-teams">${session.Team} Training</div>
                    <div class="upcoming-match-venue">${session.Venue} - ${session.Time}</div>
                `;
                upcomingTrainingList.appendChild(sessionElement);
            });
        }
        
        // Update the existing updateUpcomingMatches function to only show non-training events
        function updateUpcomingMatches(teamName) {
            const teamMatches = teamName === 'all' 
                ? matches 
                : matches.filter(match => match.Team === teamName);
            
            // Filter upcoming matches (excluding training) and remove duplicates
            const processedMatches = new Set(); // Track processed matches
            const upcomingMatches = teamMatches
                .filter(match => {
                    if (match.isTraining) return false;
                    if (match.Result && match.Result !== '---') return false;
                    
                    // Create a unique key for the match
                    const matchKey = `${match.Date}-${match.Time}-${match['Home Team']}-${match['Away Team']}-${match.Venue}`;
                    
                    // Check if we've already processed this match
                    if (processedMatches.has(matchKey)) {
                        return false;
                    }
                    
                    // Add to processed matches and keep this one
                    processedMatches.add(matchKey);
                    return true;
                })
                .sort((a, b) => parseDate(a.Date) - parseDate(b.Date))
                .slice(0, 3);
            
            const upcomingMatchesList = document.getElementById('upcomingMatchesList');
            upcomingMatchesList.innerHTML = '';
            
            if (upcomingMatches.length === 0) {
                upcomingMatchesList.innerHTML = '<p>No upcoming matches</p>';
                return;
            }
            
            upcomingMatches.forEach(match => {
                const matchElement = document.createElement('div');
                matchElement.className = 'upcoming-match';
                matchElement.innerHTML = `
                    <div class="upcoming-match-date">${formatDate(match.Date)}</div>
                    <div class="upcoming-match-teams">${match['Home Team']} vs ${match['Away Team']}</div>
                    <div class="upcoming-match-venue">${match.Venue} - ${match.Time}</div>
                `;
                upcomingMatchesList.appendChild(matchElement);
            });
        }
        
        // Populate sidebar team filter
        function populateSidebarTeamFilter() {
            console.log('Populating sidebar team filter');
            const teamFilter = document.getElementById('sidebarTeamFilter');
            
            if (!teamFilter) {
                console.error('Team filter element not found');
                return;
            }
            
            // Remove existing event listeners
            const newTeamFilter = teamFilter.cloneNode(true);
            teamFilter.parentNode.replaceChild(newTeamFilter, teamFilter);
            
            // Clear existing options except the first one
            while (newTeamFilter.options.length > 1) {
                newTeamFilter.remove(1);
            }
            
            // Get unique teams
            const teams = new Set();
            matches.forEach(match => {
                if (match.Team) teams.add(match.Team);
            });
            
            console.log('Found teams:', Array.from(teams));
            
            // Add team options
            Array.from(teams).sort().forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                newTeamFilter.appendChild(option);
            });
            
            // Add single change event listener
            newTeamFilter.addEventListener('change', function() {
                console.log('Team filter changed to:', this.value);
                updateTeamStats(this.value);
            }, { once: false });
            
            // Initialize with 'all' teams selected
            updateTeamStats('all');
        }
        
        // Initialize sidebar toggle functionality
        function initSidebarToggle() {
            console.log('Initializing sidebar toggle...');
            const sidebar = document.querySelector('.sidebar');
            const hamburgerMenu = document.getElementById('hamburgerMenu');
            const overlay = document.querySelector('.sidebar-overlay');
            
            if (!sidebar || !hamburgerMenu || !overlay) {
                console.error('Required sidebar elements not found:', { 
                    sidebar: !!sidebar, 
                    hamburgerMenu: !!hamburgerMenu, 
                    overlay: !!overlay 
                });
                return;
            }
            
            // Initialize sidebar as closed
            sidebar.classList.remove('active');
            overlay.classList.remove('active');
            
            // Remove any existing event listeners
            const newHamburger = hamburgerMenu.cloneNode(true);
            hamburgerMenu.parentNode.replaceChild(newHamburger, hamburgerMenu);
            
            // Hamburger menu click handler
            newHamburger.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                        console.log('Hamburger menu clicked');
                        sidebar.classList.toggle('active');
                        overlay.classList.toggle('active');
                document.body.style.overflow = sidebar.classList.contains('active') ? 'hidden' : '';
                    });
                
            // Overlay click handler
            overlay.addEventListener('click', () => {
                    console.log('Overlay clicked');
                    sidebar.classList.remove('active');
                    overlay.classList.remove('active');
                document.body.style.overflow = '';
                });
                
            // Close sidebar when clicking outside
            document.addEventListener('click', (event) => {
                if (!sidebar.contains(event.target) && 
                    !newHamburger.contains(event.target) && 
                    sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                        overlay.classList.remove('active');
                    document.body.style.overflow = '';
                    }
            });
                
            // Close sidebar on window resize
            window.addEventListener('resize', () => {
                if (sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                    overlay.classList.remove('active');
                    document.body.style.overflow = '';
            }
            });
        }
        
        // Initialize search functionality with autocomplete
        function initSearchAutocomplete() {
            console.log('=== initSearchAutocomplete START ===');
            const searchInput = document.getElementById('searchInput');
            console.log('Search input element:', searchInput);
            
            if (!searchInput) {
                console.error('Search input element not found!');
                return;
            }
            
            // Remove any existing suggestions container
            const existingSuggestions = document.querySelector('.autocomplete-suggestions');
            if (existingSuggestions) {
                console.log('Removing existing suggestions container');
                existingSuggestions.remove();
            }
            
            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'autocomplete-suggestions';
            searchInput.parentNode.appendChild(suggestionsContainer);
            console.log('Created new suggestions container');
            
            let currentFocus = -1;
            
            // Create a list of all searchable terms
            const searchableTerms = new Set();
            console.log('Building searchable terms from matches...');
            
            matches.forEach(match => {
                if (match.Team) searchableTerms.add(match.Team);
                if (match['Home Team']) searchableTerms.add(match['Home Team']);
                if (match['Away Team']) searchableTerms.add(match['Away Team']);
                if (match.Competition) searchableTerms.add(match.Competition);
                if (match.Venue) searchableTerms.add(match.Venue);
                if (match.Round) searchableTerms.add(match.Round);
            });
            
            console.log('Total searchable terms:', searchableTerms.size);
            
            // Add input event listener with debounce for suggestions
            searchInput.addEventListener('input', debounce(function() {
                console.log('=== Search Input Event ===');
                const val = (this.value || '').toLowerCase().trim();
                console.log('Current input value:', val);
                
                suggestionsContainer.innerHTML = '';
                
                if (val.length < 2) {
                    console.log('Input too short, hiding suggestions');
                    suggestionsContainer.style.display = 'none';
                    displayMatches(); // Update display when search is cleared
                    return;
                }
                
                const matchingTerms = Array.from(searchableTerms)
                    .filter(term => term && term.toLowerCase().includes(val))
                    .slice(0, 5);
                
                console.log('Matching suggestions:', matchingTerms);
                
                if (matchingTerms.length > 0) {
                    matchingTerms.forEach(term => {
                        const div = document.createElement('div');
                        div.className = 'autocomplete-suggestion';
                        div.innerHTML = term;
                        div.addEventListener('click', function() {
                            console.log('Suggestion clicked:', term);
                            searchInput.value = term;
                            suggestionsContainer.style.display = 'none';
                            displayMatches();
                        });
                        suggestionsContainer.appendChild(div);
                    });
                    suggestionsContainer.style.display = 'block';
                } else {
                    console.log('No matching suggestions found');
                    suggestionsContainer.style.display = 'none';
                }
                
                displayMatches(); // Update display with search results
                currentFocus = -1;
            }, 300));
            
            // Add keyboard navigation
            searchInput.addEventListener('keydown', function(e) {
                console.log('=== Keyboard Event ===');
                console.log('Key pressed:', e.key);
                
                const suggestions = suggestionsContainer.getElementsByClassName('autocomplete-suggestion');
                console.log('Current suggestions count:', suggestions.length);
                
                if (suggestions.length > 0) {
                    if (e.key === 'ArrowDown') {
                        currentFocus++;
                        if (currentFocus >= suggestions.length) currentFocus = 0;
                        setActiveSuggestion(suggestions);
                    } else if (e.key === 'ArrowUp') {
                        currentFocus--;
                        if (currentFocus < 0) currentFocus = suggestions.length - 1;
                        setActiveSuggestion(suggestions);
                    } else if (e.key === 'Enter' && currentFocus > -1) {
                        e.preventDefault();
                        const selectedTerm = suggestions[currentFocus].textContent;
                        console.log('Selected suggestion:', selectedTerm);
                        searchInput.value = selectedTerm;
                        suggestionsContainer.style.display = 'none';
                        displayMatches();
                    }
                }
            });
            
            function setActiveSuggestion(suggestions) {
                console.log('Setting active suggestion, current focus:', currentFocus);
                Array.from(suggestions).forEach((s, i) => {
                    s.classList.remove('active');
                    if (i === currentFocus) s.classList.add('active');
                });
            }
            
            // Close suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!searchInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    console.log('Click outside search area, hiding suggestions');
                    suggestionsContainer.style.display = 'none';
                }
            });
            
            // Add reset search button handler
            const resetSearchBtn = document.getElementById('resetSearch');
            if (resetSearchBtn) {
                resetSearchBtn.addEventListener('click', () => {
                    console.log('Reset search clicked');
                    searchInput.value = '';
                    suggestionsContainer.style.display = 'none';
                    displayMatches();
                });
            }
            
            console.log('=== initSearchAutocomplete END ===');
        }

        // Start the app when the DOM is loaded
        document.addEventListener('DOMContentLoaded', init);

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // User Preferences
        const userPreferences = {
            get: key => localStorage.getItem(key),
            set: (key, value) => localStorage.setItem(key, value),
            remove: key => localStorage.removeItem(key)
        };

        // Add to Home Screen
        let deferredPrompt;
        const addToHome = document.querySelector('.add-to-home');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;

            // Show the prompt if user hasn't dismissed it before
            if (!userPreferences.get('installPromptDismissed')) {
                addToHome.classList.add('show');
            }
        });

        document.querySelector('.install-btn').addEventListener('click', async () => {
            addToHome.classList.remove('show');
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                deferredPrompt = null;
                userPreferences.set('installPromptDismissed', 'true');
            }
        });

        document.querySelector('.close-btn').addEventListener('click', () => {
            addToHome.classList.remove('show');
            userPreferences.set('installPromptDismissed', 'true');
        });

        // Push Notifications
        const notificationPrompt = document.querySelector('.notification-prompt');

        async function initializeNotifications() {
            if (!('Notification' in window)) return;
            
            if (Notification.permission === 'default' && !userPreferences.get('notificationPromptDismissed')) {
                notificationPrompt.classList.add('show');
            }
        }

        document.querySelector('.allow-btn').addEventListener('click', async () => {
            notificationPrompt.classList.remove('show');
            try {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    const registration = await navigator.serviceWorker.ready;
                    const subscription = await registration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: 'YOUR_VAPID_PUBLIC_KEY' // You'll need to replace this with your actual VAPID key
                    });
                    // Here you would typically send the subscription to your server
                    console.log('Push notification subscription:', subscription);
                }
            } catch (error) {
                console.error('Error setting up push notifications:', error);
            }
            userPreferences.set('notificationPromptDismissed', 'true');
        });

        document.querySelector('.deny-btn').addEventListener('click', () => {
            notificationPrompt.classList.remove('show');
            userPreferences.set('notificationPromptDismissed', 'true');
        });

        // Initialize notifications after page load
        window.addEventListener('load', initializeNotifications);

        // Add these constants at the top of your script
        const GOOGLE_API_KEY = 'YOUR_API_KEY'; // Replace with your API key
        const CALENDAR_ID = '93e86f000690d251948613ab5ddebf7af6199f80d71ecda06e3f0c4c7d5fb290@group.calendar.google.com'; // Replace with your calendar ID
        
        // Add this to your initialization code
        async function initGoogleCalendar() {
            try {
                await gapi.load('client', async () => {
                    await gapi.client.init({
                        apiKey: GOOGLE_API_KEY,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest']
                    });
                    
                    console.log('Google Calendar API initialized');
                    // Start loading training events
                    await loadTrainingEvents();
                });
            } catch (error) {
                console.error('Error initializing Google Calendar:', error);
            }
        }
        
        async function loadTrainingEvents() {
            try {
                console.log('Loading training events...');
                const response = await gapi.client.calendar.events.list({
                    'calendarId': CALENDAR_ID,
                    'timeMin': (new Date()).toISOString(),
                    'showDeleted': false,
                    'singleEvents': true,
                    'maxResults': 100,
                    'orderBy': 'startTime'
                });

                console.log('Calendar response:', response);
                const events = response.result.items;
                const trainingEvents = events.map(event => ({
                    'Date': new Date(event.start.dateTime || event.start.date).toLocaleDateString('en-GB', {
                        weekday: 'short',
                        day: 'numeric',
                        month: 'short',
                        year: '2-digit'
                    }),
                    'Time': event.start.dateTime ? 
                            new Date(event.start.dateTime).toLocaleTimeString('en-GB', {hour: '2-digit', minute:'2-digit'}) : 
                            'All Day',
                    'EndTime': event.end.formattedTime,
                    'Competition': 'Training',
                    'Team': event.summary.split(' ')[0],
                    'Home Team': 'Training',
                    'Away Team': '',
                    'Venue': event.location || 'TBD',
                    'Result': '---',
                    'Fixture ID': `training-${event.id}`,
                    'Fixture Src': 'google-calendar',
                    'isTraining': true,
                    'Description': event.description || ''
                }));

                console.log('Training events:', trainingEvents);
                // Merge training events with matches
                mergeAndDisplayEvents(trainingEvents);
            } catch (error) {
                console.error('Error loading training events:', error);
            }
        }
        
        function mergeAndDisplayEvents(trainingEvents) {
            // Get current matches after applying all filters
            const currentMatches = filterMatches();
            
            // Combine filtered matches and training events
            const allEvents = [...currentMatches, ...trainingEvents].sort((a, b) => {
                return new Date(a.Date + ' ' + a.Time) - new Date(b.Date + ' ' + b.Time);
            });
            
            // Update display with combined events
            displayMatches(allEvents);
        }
        
        // Store original function BEFORE any modifications
        const originalCreateMatchCard = createMatchCard;

        // Modified createMatchCard function
        createMatchCard = function(match) {
            console.log('Creating match card for:', match);
            if (match.isTraining) {
                const matchCard = document.createElement('div');
                matchCard.className = 'match-card training';
                
                matchCard.innerHTML = `
                    <div class="match-content">
                        <div class="match-header">
                            <span class="competition">${match.Competition}</span>
                            <span class="team">${match.Team}</span>
                        </div>
                        <div class="metadata">
                            <span class="venue">${match.Venue}</span>
                            <span class="time">${match.Time} - ${match.EndTime}</span>
                            <span class="badge training">Training</span>
                        </div>
                    </div>
                `;
                return matchCard;
            }
            return originalCreateMatchCard(match);
        };

        // Add styles for the enhanced training cards
        const style = document.createElement('style');
        style.textContent = `
            .match-card.training {
                border-left: 4px solid #4a90e2;
                background-color: #f8f9fa;
            }
            
            .match-card.training .badge.training {
                background-color: #4a90e2;
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 0.8em;
            }

            .match-card.training .match-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 8px;
            }

            .match-card.training .team {
                font-weight: bold;
                color: #2c3e50;
            }
            
            .match-card.training .metadata {
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center;
                font-size: 0.9em;
                color: #666;
            }

            .match-card.training .venue {
                color: #2c3e50;
                font-style: italic;
            }

            .match-card.training .venue-type {
                color: #e74c3c;
                font-weight: 500;
            }

            .match-card.training .time {
                color: #2c3e50;
                font-weight: 500;
            }
        `;
        document.head.appendChild(style);

        // Fetch training events function
        async function fetchTrainingEvents() {
            try {
                console.log('Starting to fetch training events...');
                const response = await fetch('https://calendar-training-worker.ardmhacha.workers.dev/', {
                    method: 'GET',
                    mode: 'cors',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch training events: ${response.status}`);
                }
                
                const events = await response.json();
                console.log('Raw calendar events:', events);
                
                if (!events.items) {
                    console.error('No items in events response:', events);
                    return;
                }

                // Get existing non-training matches
                const existingMatches = matches.filter(m => !m.isTraining);
                console.log('Existing non-training matches:', existingMatches.length);
                
                // Process training events
                const trainingMatches = events.items.map(event => {
                    const startDateTime = new Date(event.start.dateTime || event.start.date);
                    const endDateTime = new Date(event.end.dateTime || event.end.date);
                    
                    return {
                        'Date': formatDate(startDateTime),
                        'Time': startDateTime.toLocaleTimeString('en-GB', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }),
                        'EndTime': endDateTime.toLocaleTimeString('en-GB', {
                            hour: '2-digit',
                            minute: '2-digit',
                            hour12: false
                        }),
                        'Competition': '',
                        'Team': event.summary,
                        'Home Team': '',
                        'Away Team': '',
                        'Venue': event.location || 'TBD',
                        'Result': '---',
                        'Fixture ID': `training-${event.id}`,
                        'Fixture Src': 'google-calendar',
                        'isTraining': true
                    };
                });
                console.log('Processed training matches:', trainingMatches.length);

                // Combine matches and sort
                matches = [...existingMatches, ...trainingMatches].sort((a, b) => {
                    const dateA = parseDate(a.Date);
                    const dateB = parseDate(b.Date);
                    if (dateA.getTime() === dateB.getTime()) {
                        return (a.Time || '00:00').localeCompare(b.Time || '00:00');
                    }
                    return dateA - dateB;
                });

                console.log('Total matches after combining:', matches.length);
                displayMatches();

            } catch (error) {
                console.error('Error in fetchTrainingEvents:', error);
            }
        }

        // Initialize the application
        async function init() {
            console.log('=== init START ===');
            try {
                // Initialize empty matches array
                matches = [];
                console.log('Initialized empty matches array');
                
                // Wait for DOM to be fully loaded
                if (document.readyState === 'loading') {
                    console.log('DOM not fully loaded, waiting...');
                    await new Promise(resolve => {
                        document.addEventListener('DOMContentLoaded', resolve);
                    });
                    console.log('DOM fully loaded');
                }
                
                // Fetch matches from worker
                console.log('Starting to fetch matches from worker...');
                const workerMatches = await fetchMatchesFromWorker();
                console.log('Worker matches fetched:', workerMatches.length);
                matches = workerMatches; // Replace instead of concat
                
                // Fetch training events
                console.log('Starting to fetch training events...');
                await fetchTrainingEvents();
                console.log('Training events fetched, total matches now:', matches.length);
                
                // Initialize UI after data is loaded
                console.log('Initializing UI...');
                initializeUI();
                
                // Initialize search functionality
                console.log('Initializing search functionality...');
                initSearchAutocomplete();
                
                console.log('Initialization complete. Final match count:', matches.length);
                
            } catch (error) {
                console.error('Error in init:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('matchContainer').innerHTML = `
                    <div class="no-results">
                        <p>Error loading matches. Please try refreshing the page.</p>
                        <p>Error details: ${error.message}</p>
                    </div>
                `;
            }
            console.log('=== init END ===');
        }

        // Separate UI initialization
        function initializeUI() {
            try {
                console.log('Initializing UI...');
                
                // Initialize date picker
                flatpickr("#dateRange", {
                    mode: "range",
                    dateFormat: "D M d Y",
                    onChange: function(selectedDates, dateStr, instance) {
                        console.log('Date changed:', selectedDates);
                        displayMatches();
                        updateFilterAlert();
                    },
                    onClose: function(selectedDates, dateStr, instance) {
                        console.log('Date picker closed:', selectedDates);
                        updateFilterAlert();
                    }
                });
                
                // Initialize sidebar
                initSidebarToggle();
                
                // Add toggle event listeners
                const showMatchesToggle = document.getElementById('showMatches');
                const showTrainingToggle = document.getElementById('showTraining');
                
                if (showMatchesToggle && showTrainingToggle) {
                    showMatchesToggle.addEventListener('change', () => {
                        console.log('Matches toggle changed:', showMatchesToggle.checked);
                        displayMatches();
                    });
                    
                    showTrainingToggle.addEventListener('change', () => {
                        console.log('Training toggle changed:', showTrainingToggle.checked);
                        displayMatches();
                    });
                }
                
                // Populate team filter and initialize stats
                populateSidebarTeamFilter();
                
                // Display initial matches
                displayMatches();
                
                console.log('UI initialization complete');
            } catch (error) {
                console.error('Error initializing UI:', error);
                throw error;
            }
        }

        // Remove any other DOMContentLoaded listeners and use just this one
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing...');
            init().catch(error => console.error('Initialization error:', error));
        });

        // Function to create Google Calendar URL
        function createCalendarUrl(match, title, location) {
            const params = new URLSearchParams({
                action: 'TEMPLATE',
                text: title,
                dates: `${match.calendarStart.replace(/[-:]/g, '')}/${match.calendarEnd.replace(/[-:]/g, '')}`,
                details: `Training session for ${title}`,
                location: location || 'Grange Grounds'
            });
            
            return `https://calendar.google.com/calendar/render?${params.toString()}`;
        }

        // Add styles for calendar link
        const calendarStyle = document.createElement('style');
        calendarStyle.textContent = `
            .match-card .calendar-link {
                margin-top: 8px;
                text-align: right;
            }
            
            .match-card .calendar-link a {
                color: #4a90e2;
                text-decoration: none;
                font-size: 0.9em;
                display: inline-flex;
                align-items: center;
                gap: 4px;
            }
            
            .match-card .calendar-link a:hover {
                text-decoration: underline;
            }
        `;
        document.head.appendChild(calendarStyle);

        document.addEventListener('DOMContentLoaded', function() {
            const hamburgerMenu = document.getElementById('hamburgerMenu');
            const sidebar = document.querySelector('.sidebar');
            
            hamburgerMenu.addEventListener('click', function() {
                sidebar.classList.toggle('active');
            });
            
            // Close sidebar when clicking outside
            document.addEventListener('click', function(event) {
                if (!sidebar.contains(event.target) && 
                    !hamburgerMenu.contains(event.target) && 
                    sidebar.classList.contains('active')) {
                    sidebar.classList.remove('active');
                }
            });
            
            // ... existing code ...
        });

        async function fetchMatchesFromWorker() {
            console.log('Fetching matches from worker...');
            try {
                console.log('Making request to worker URL: https://calendar-matches-worker.ardmhacha.workers.dev/');
                const response = await fetch('https://calendar-matches-worker.ardmhacha.workers.dev/');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log('Raw response from worker:', data);

                // Check if we have the expected data structure
                if (!data.success || !data.data || !Array.isArray(data.data)) {
                    console.error('Unexpected response structure:', data);
                    throw new Error('Invalid response format from worker');
                }

                const workerMatches = data.data;
                console.log('Number of matches received:', workerMatches.length);

                // Process worker matches to match our format
                const processedMatches = workerMatches.map(match => {
                    console.log('Processing match:', match);
                    console.log('Sex value:', match.Sex);
                    console.log('Round value:', match.Round);
                    
                    const processedMatch = {
                        'Date': match.Date,
                        'Time': match.Time,
                        'Competition': match.Competition,
                        'Sex': match.Sex || '',  // Provide default empty string if undefined
                        'Round': match.Round || '', // Provide default empty string if undefined
                        'Team': match.Team,
                        'Home Team': match['Home Team'],
                        'Away Team': match['Away Team'],
                        'Home Score': match['Home Score'],
                        'Away Score': match['Away Score'],
                        'Venue': match.Venue,
                        'Referee': match.Referee,
                        'Result': match.Result || '',
                        'Fixture ID': match['Fixture ID'],
                        'Fixture Src': match['Fixture Src'],
                        'isTraining': false
                    };
                    
                    console.log('Processed match object:', processedMatch);
                    return processedMatch;
                });

                console.log('Processed worker matches:', processedMatches);
                console.log('Total processed matches:', processedMatches.length);
                return processedMatches;
            } catch (error) {
                console.error('Error in fetchMatchesFromWorker:', error);
                console.error('Error details:', error.message);
                return [];
            }
        }

        // Sidebar and Team Stats Management
        function initSidebarToggle() {
            const sidebar = document.querySelector('.sidebar');
            const hamburgerMenu = document.querySelector('.hamburger-menu');
            const overlay = document.querySelector('.sidebar-overlay');
            
            if (!sidebar || !hamburgerMenu || !overlay) {
                console.error('Required sidebar elements not found');
                return;
            }
            
            // Initialize sidebar state
            const isMobile = window.innerWidth <= 992;
            if (isMobile) {
                sidebar.classList.add('collapsed');
                hamburgerMenu.classList.add('active');
            }
            
            // Hamburger menu click handler
            hamburgerMenu.addEventListener('click', () => {
                console.log('Hamburger menu clicked');
                sidebar.classList.toggle('collapsed');
                hamburgerMenu.classList.toggle('active');
                overlay.classList.toggle('active');
                document.body.classList.toggle('sidebar-open');
            });
            
            // Overlay click handler
            overlay.addEventListener('click', () => {
                console.log('Overlay clicked');
                sidebar.classList.add('collapsed');
                hamburgerMenu.classList.remove('active');
                overlay.classList.remove('active');
                document.body.classList.remove('sidebar-open');

            });
            
            // Window resize handler
            window.addEventListener('resize', () => {
                const isMobile = window.innerWidth <= 992;
                if (isMobile) {
                    sidebar.classList.add('collapsed');
                    hamburgerMenu.classList.add('active');
                } else {
                    sidebar.classList.remove('collapsed');
                    hamburgerMenu.classList.remove('active');
                    overlay.classList.remove('active');
                    document.body.classList.remove('sidebar-open');
                }
            });
        }

        function updateTeamStats(teamName) {
            console.log('******Updating team stats for:', teamName);
            
            console.log('First 30 matches in dataset:', matches.slice(0, 30).map(m => ({
                Date: m.Date,
                Team: m.Team,
                Competition: m.Competition,
                'Home Team': m['Home Team'],
                'Away Team': m['Away Team'],
                isTraining: m.isTraining,
                Result: m.Result
            })));
            
            const stats = {
                total: 0,
                wins: 0,
                losses: 0,
                draws: 0,
                upcoming: 0
            };
            
            // Get all non-training matches for the selected team
            const teamMatches = teamName === 'all' 
                ? matches.filter(match => !match.isTraining)
                : matches.filter(match => match.Team === teamName && !match.isTraining);
            
            console.log('******Filtered matches for stats:', teamMatches);
            
            // Count each match only once
            teamMatches.forEach(match => {
                stats.total++;
                
                if (match.Result === 'WIN') {
                    stats.wins++;
                } else if (match.Result === 'LOSS') {
                    stats.losses++;
                } else if (match.Result === 'DRAW') {
                    stats.draws++;
                } else if (match.Result === '---' || !match.Result) {
                    stats.upcoming++;
                }
            });
            
            console.log('********Calculated stats:', stats);
            
            // Update sidebar stats
            const totalCount = document.getElementById('sidebarTotalCount');
            const winCount = document.getElementById('sidebarWinCount');
            const lossCount = document.getElementById('sidebarLossCount');
            const drawCount = document.getElementById('sidebarDrawCount');
            const upcomingCount = document.getElementById('sidebarUpcomingCount');
            
            if (totalCount) totalCount.textContent = stats.total;
            if (winCount) winCount.textContent = stats.wins;
            if (lossCount) lossCount.textContent = stats.losses;
            if (drawCount) drawCount.textContent = stats.draws;
            if (upcomingCount) upcomingCount.textContent = stats.upcoming;
            
            // Update upcoming matches and training sessions
            updateUpcomingMatches(teamName);
            updateUpcomingTraining(teamName);
        }

        function populateSidebarTeamFilter() {
            console.log('Populating sidebar team filter');
            const teamFilter = document.getElementById('sidebarTeamFilter');
            
            if (!teamFilter) {
                console.error('Team filter element not found');
                return;
            }
            
            // Remove existing event listeners
            const newTeamFilter = teamFilter.cloneNode(true);
            teamFilter.parentNode.replaceChild(newTeamFilter, teamFilter);
            
            // Clear existing options except the first one
            while (newTeamFilter.options.length > 1) {
                newTeamFilter.remove(1);
            }
            
            // Get unique teams
            const teams = new Set();
            matches.forEach(match => {
                if (match.Team) teams.add(match.Team);
            });
            
            console.log('Found teams:', Array.from(teams));
            
            // Add team options
            Array.from(teams).sort().forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                newTeamFilter.appendChild(option);
            });
            
            // Add single change event listener
            newTeamFilter.addEventListener('change', function() {
                console.log('Team filter changed to:', this.value);
                updateTeamStats(this.value);
            }, { once: false });
            
            // Initialize with 'all' teams selected
            updateTeamStats('all');
        }

        // Initialize everything when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing components');
            initSidebarToggle();
            populateSidebarTeamFilter();
            // ... existing initialization code ...
        });

        // ... existing code ...
        // Remove any other DOMContentLoaded listeners and use just this one
        let initializationInProgress = false;

        async function init() {
            // Prevent multiple initializations
            if (initializationInProgress) {
                console.log('Initialization already in progress, skipping...');
                return;
            }
            
            initializationInProgress = true;
            console.log('=== init START ===');
            
            try {
                // Initialize empty matches array
                matches = [];
                console.log('Initialized empty matches array');
                
                // Fetch matches from worker first
                console.log('Starting to fetch matches from worker...');
                const workerMatches = await fetchMatchesFromWorker();
                console.log('Worker matches fetched:', workerMatches.length);
                matches = workerMatches; // Replace instead of concat
                
                // Fetch training events
                console.log('Starting to fetch training events...');
                await fetchTrainingEvents();
                console.log('Training events fetched, total matches now:', matches.length);
                
                // Initialize UI only after all data is loaded
                console.log('Initializing UI...');
                initializeUI();
                
                // Initialize search functionality
                console.log('Initializing search functionality...');
                initSearchAutocomplete();
                
                console.log('Initialization complete. Final match count:', matches.length);
                
            } catch (error) {
                console.error('Error in init:', error);
                console.error('Error stack:', error.stack);
                document.getElementById('matchContainer').innerHTML = `
                    <div class="no-results">
                        <p>Error loading matches. Please try refreshing the page.</p>
                        <p>Error details: ${error.message}</p>
                    </div>
                `;
            } finally {
                initializationInProgress = false;
                console.log('=== init END ===');
            }
        }

        // Clean up multiple event listeners
        document.removeEventListener('DOMContentLoaded', init);
        window.removeEventListener('load', init);

        // Add single initialization point
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init, { once: true });
        } else {
            init();
        }

        // Remove the duplicate initialization in the service worker section
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }

        // Update initializeUI to not reinitialize if already done
        let uiInitialized = false;

        function initializeUI() {
            if (uiInitialized) {
                console.log('UI already initialized, skipping...');
                return;
            }
            
            try {
                console.log('Initializing UI...');
                
                // Initialize date picker
                flatpickr("#dateRange", {
                    mode: "range",
                    dateFormat: "D M d Y",
                    onChange: function(selectedDates, dateStr, instance) {
                        console.log('Date changed:', selectedDates);
                        displayMatches();
                        updateFilterAlert();
                    },
                    onClose: function(selectedDates, dateStr, instance) {
                        console.log('Date picker closed:', selectedDates);
                        updateFilterAlert();
                    }
                });
                
                // Initialize sidebar
                initSidebarToggle();
                
                // Add toggle event listeners
                const showMatchesToggle = document.getElementById('showMatches');
                const showTrainingToggle = document.getElementById('showTraining');
                
                if (showMatchesToggle && showTrainingToggle) {
                    showMatchesToggle.addEventListener('change', () => {
                        console.log('Matches toggle changed:', showMatchesToggle.checked);
                        displayMatches();
                    });
                    
                    showTrainingToggle.addEventListener('change', () => {
                        console.log('Training toggle changed:', showTrainingToggle.checked);
                        displayMatches();
                    });
                }
                
                // Populate team filter and initialize stats
                populateSidebarTeamFilter();
                
                // Display initial matches
                displayMatches();

                //add today button
                initScrollToTodayButton();  
                
                uiInitialized = true;
                console.log('UI initialization complete');
            } catch (error) {
                console.error('Error initializing UI:', error);
                throw error;
            }
        }
        // ... existing code ...

        document.addEventListener('DOMContentLoaded', function() {
            const controls = document.querySelector('.controls');
            const filterToggle = document.getElementById('filterToggle');

            if (!controls || !filterToggle) {
                console.error('Controls section or filter toggle button not found.');
                return;
            }
    
            // Set initial state: hidden
            controls.classList.add('hidden');
            let isManuallyCollapsed = false;

            // Create and add internal toggle button
            const toggleButton = document.createElement('button');
            toggleButton.className = 'controls-toggle';
            toggleButton.innerHTML = '<i class="fas fa-chevron-up"></i>';
            controls.appendChild(toggleButton);

            // Manual toggle of collapsed/expanded (only used when visible)
            function toggleControlsManually() {
                const isCollapsed = controls.classList.contains('collapsed');
                controls.classList.toggle('collapsed');
                isManuallyExpanded = !isCollapsed;

                toggleButton.innerHTML = isCollapsed
                    ? '<i class="fas fa-chevron-up"></i>'
                    : '<i class="fas fa-chevron-down"></i>';
            }

            toggleButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleControlsManually();
            });

            // Toggle visibility of controls from top chevron
            filterToggle.addEventListener('click', function () {
                const isHidden = controls.classList.contains('hidden');

                if (isHidden) {
                    // Show fully expanded
                    controls.classList.remove('hidden');
                    controls.classList.remove('collapsed');
                    isManuallyExpanded = true;

                    const icon = filterToggle.querySelector('i');
                    icon.classList.remove('fa-chevron-up');
                    icon.classList.add('fa-chevron-down');

                    toggleButton.innerHTML = '<i class="fas fa-chevron-up"></i>';
                } else {
                    // Hide completely
                    controls.classList.add('hidden');
                    controls.classList.remove('collapsed');
                    isManuallyExpanded = false;

                    const icon = filterToggle.querySelector('i');
                    icon.classList.remove('fa-chevron-down');
                    icon.classList.add('fa-chevron-up');
                }
            });

            // Hide on scroll
            window.addEventListener('scroll', () => {
                if (!controls.classList.contains('hidden')) {
                    controls.classList.add('hidden');
                    controls.classList.remove('collapsed');
                    isManuallyExpanded = false;
                }

                // toggle scroll-to-today button visibility
                const todayMarker = document.getElementById('todayMarker');
                const scrollToTodayBtn = document.getElementById('scrollToTodayBtn');
                if (todayMarker && scrollToTodayBtn) {
                    const rect = todayMarker.getBoundingClientRect();
                    const isVisible = rect.bottom > 0 && rect.top < window.innerHeight;;
                    scrollToTodayBtn.style.display = isVisible ? 'none' : 'block';
                }
            });

            // Hide on click outside
            document.addEventListener('click', function (event) {
                const isClickInsideControls = controls.contains(event.target);
                const isClickOnToggle = filterToggle.contains(event.target);

                if (!isClickInsideControls && !isClickOnToggle) {
                    controls.classList.add('hidden');
                    controls.classList.remove('collapsed');
                    isManuallyExpanded = false;
                }
            });
        });
            
        // CSS to make the filter toggle button sticky
        const filterToggleStyle = document.createElement('style');
        filterToggleStyle.innerHTML = `
            #filterToggle {
                position: sticky;
                top: 0;
                z-index: 1000;
            }
        `;
        document.head.appendChild(filterToggleStyle);

        // Existing script
        function updateFilterAlert() {
            console.log('Updating filter alert');
            const filterAlert = document.getElementById('filterAlert');
            const searchInput = document.getElementById('searchInput');
            const dateInput = document.getElementById('dateRange');

            const hasSearch = searchInput && searchInput.value.trim().length > 0;
            const hasDate = dateInput && dateInput._flatpickr && dateInput._flatpickr.selectedDates && dateInput._flatpickr.selectedDates.length > 0;

            console.log('Has search:', hasSearch);
            console.log('Has date:', hasDate);
            console.log('Date input value:', dateInput ? dateInput.value : 'no date input');
            console.log('Flatpickr dates:', dateInput && dateInput._flatpickr ? dateInput._flatpickr.selectedDates : 'no flatpickr');

            if (hasSearch || hasDate) {
                console.log('Showing filter alert');
                filterAlert.style.display = 'block';
            } else {
                console.log('Hiding filter alert');
                filterAlert.style.display = 'none';
            }
        }

        // Call updateFilterAlert when filters change
        document.getElementById('searchInput').addEventListener('input', updateFilterAlert);

        // Add event listener to reset buttons
        const resetSearchBtn = document.getElementById('resetSearch');
        if (resetSearchBtn) {
            resetSearchBtn.addEventListener('click', () => {
                document.getElementById('searchInput').value = '';
                updateFilterAlert();
            });
        }

        const resetDateBtn = document.getElementById('resetDate');
        if (resetDateBtn) {
            resetDateBtn.addEventListener('click', () => {
                const dateInput = document.getElementById('dateRange');
                if (dateInput && dateInput._flatpickr) {
                    dateInput._flatpickr.clear();
                }
                updateFilterAlert();
            });
        }

        // Add clear filters functionality
        document.getElementById('clearFiltersBtn').addEventListener('click', function() {
            // Clear search input
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            // Clear date range
            const dateInput = document.getElementById('dateRange');
            if (dateInput && dateInput._flatpickr) {
                dateInput._flatpickr.clear();
            }
            
            // Update display
            displayMatches();
            updateFilterAlert();
        });

        // Add hover effect for the clear button
        const clearBtn = document.getElementById('clearFiltersBtn');
        clearBtn.addEventListener('mouseover', function() {
            this.style.color = '#000';
        });
        clearBtn.addEventListener('mouseout', function() {
            this.style.color = '#666';
        });

        function initScrollToTodayButton() {
            if (document.getElementById('scrollToTodayBtn')) return; // Already added
            const scrollToTodayBtn = document.createElement('button');
            scrollToTodayBtn.id = 'scrollToTodayBtn';
            scrollToTodayBtn.innerHTML = '<i class="fas fa-calendar-day"></i> Today';
            scrollToTodayBtn.className = 'scroll-to-today-btn';
            document.body.appendChild(scrollToTodayBtn);

            scrollToTodayBtn.addEventListener('click', () => {
                const todayMarker = document.getElementById('todayMarker');
                if (todayMarker) {
                    todayMarker.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }
    </script>
</body>
</html>


